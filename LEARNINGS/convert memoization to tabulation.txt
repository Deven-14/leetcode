from functools import cache

class Solution:
    def sol(self, k, A, n) -> int:
        
        @cache
        def helper(i, energy):
            if i == n:  
                return 0  # Base case: No more days

            # Option 1: Move ahead, but only if we have energy left
            d1 = 0
            if energy > 0:  
                d1 = A[i] + helper(i + 1, energy - 1)

            # Option 2: Stay put and gain 1 energy
            d2 = helper(i + 1, energy + 1)

            return max(d1, d2)

        return helper(0, k)


Converting a **recursive memoization** (top-down DP) solution to a **tabulation** (bottom-up DP) solution can be tricky, but here are **some key steps and pointers** to help with the process.

---

## **üìå Steps to Convert Recursion + Memoization to Tabulation**
### **Step 1: Identify the State Variables**
- In your recursive function, the parameters that **change** during the recursion define the **state**.
- In your case:  
  - `i` (current day) ‚Üí corresponds to **rows** in the DP table.
  - `energy` (remaining energy) ‚Üí corresponds to **columns** in the DP table.

---

### **Step 2: Create a DP Table**
- If `n = len(A)`, we define a **2D table `dp[i][energy]`**:
  - `dp[i][e]` stores the **maximum distance** we can travel on day `i` with `e` energy left.
  - The dimensions of `dp` are **(n+1) x (max possible energy + 1)**.

---

### **Step 3: Define the Base Case**
- The last row (day `n`) in the DP table should be **initialized to `0`** because once we reach `n`, we cannot travel anymore.

---

### **Step 4: Fill the DP Table Bottom-Up**
- Since recursion works **top-down**, tabulation works **bottom-up**.
- We **iterate from the last day (`n-1`) to the first day (`0`)** and **fill the DP table iteratively**.

- **Transition Formula (from recursion to iteration)**:
  - If we **move forward**:  
    \[
    dp[i][e] = A[i] + dp[i + 1][e - 1] \quad \text{(only if \( e > 0 \))}
    \]
  - If we **stay put** (gain energy):
    \[
    dp[i][e] = \max(dp[i][e], dp[i + 1][e + 1])
    \]

- **Final answer** is stored in `dp[0][k]` (starting from day `0` with `k` energy).

---

## **‚úÖ Tabulated Version (Bottom-Up DP)**
```python
class Solution:
    def sol(self, k, A, n) -> int:
        max_energy = k + n  # Max possible energy we can have
        dp = [[0] * (max_energy + 1) for _ in range(n + 1)]
        
        for i in range(n - 1, -1, -1):  # Traverse days in reverse order
            for e in range(max_energy):  # Energy cannot exceed max_energy
                # Move forward if energy > 0
                if e > 0:
                    dp[i][e] = A[i] + dp[i + 1][e - 1]
                
                # Stay put and gain 1 energy
                dp[i][e] = max(dp[i][e], dp[i + 1][e + 1])

        return dp[0][k]
```

---

## **üìå Key Differences Between Memoization and Tabulation**
| Feature  | Recursive + Memoization | Iterative Tabulation |
|----------|-----------------|------------------|
| Approach | Top-down (solve subproblems as needed) | Bottom-up (solve small cases first) |
| Storage  | Uses a **dictionary (cache)** or a 2D **DP array** | Uses a **2D DP table** |
| Base Case | Handled in recursive calls | Explicitly initialized in DP table |
| Iteration | Recursive function calls | Iterative loops |
| Efficiency | Usually `O(n * k)`, but recursion can have overhead | Always `O(n * k)`, more efficient |
| Stack Space | Uses recursive stack | Uses only DP array (no recursion) |

---

## **üöÄ Summary of Key Pointers**
1Ô∏è‚É£ **Identify State Variables** ‚Üí Check which parameters are changing in recursion (`i, energy`).  
2Ô∏è‚É£ **Define a DP Table** ‚Üí Create a table `dp[i][e]` where `i` is the index (days) and `e` is the remaining energy.  
3Ô∏è‚É£ **Set Base Case** ‚Üí The last row (`dp[n][e]`) should be `0` since no movement is possible.  
4Ô∏è‚É£ **Fill Table Bottom-Up** ‚Üí Use loops to **iterate from `n-1` to `0`**, mimicking recursive calls.  
5Ô∏è‚É£ **Use Transition Formula** ‚Üí Convert recursive choices into iterative updates.  
6Ô∏è‚É£ **Return the Answer from `dp[0][k]`** ‚Üí This represents the **maximum distance possible starting from day `0` with `k` energy**.  

---

### **üî• Advantage of Tabulation Over Memoization**
- **Avoids recursion overhead** ‚Üí No function call stack issues.
- **More memory efficient** in some cases ‚Üí Can use **1D DP instead of 2D** if we only depend on `dp[i+1]`.

This method guarantees that **your solution runs efficiently** for `n < 1000`. üöÄ






Choosing between the 3 methods:


Techniques
    1. Recursive (Top-Down)
        1. 10, 9, 8,... with base conditions
    2. Top-Down iteractive
        1. 10, 9, 8,... with base conditions using dp[] or cache{}
        2. the for loop runs from n-1 to 0
        3. Less common
    3. Bottom-Up iteractive
        1. 0, 1, from base conditions, ... to 8, 9, 10
        2. uses dp[] or cache{}
        3. the for loop runs from 0 to n-1


Choosing between recursive top-down (memoization), iterative top-down, and iterative bottom-up in DP is mostly about state dependency direction, constraints, and implementation risk. Here‚Äôs a practical decision framework you can use in interviews or real problems.

Step 1: Start with the dependency graph (most important)
Ask:
Does a state depend on smaller/simpler states in a clear order?


If dependencies naturally go from small ‚Üí large
Example:
dp[i] depends on dp[i-1], dp[i-2]
dp[i][j] depends on dp[i-1][j], dp[i][j-1]

‚Üí Use Iterative Bottom-Up
Why?
Natural table filling order
Fastest (no recursion overhead)
Memory can often be optimized
Typical problems
Fibonacci
Knapsack
LCS / Edit Distance
Grid paths


If dependency order is complex or conditional
Example:
State depends on variable transitions
Hard to know fill order
Graph-like transitions

‚Üí Use Recursive Top-Down (Memoization)
Why?
You compute only needed states
No need to figure iteration order
Cleaner for branching logic
Typical problems
Word Break
Partition problems
DP on trees
Digit DP
Game DP / minimax
When transitions depend on conditions or loops


Step 2: Check constraints (performance / memory)
Use Bottom-Up when:
All states will be needed anyway
Constraints are large (e.g., n = 10^5)
Recursion depth may overflow
You need optimal performance

Rule of thumb

If states ‚âà input size and all will be visited ‚Üí Bottom-Up
Use Top-Down when:
Many states won‚Äôt be visited
State space is large but sparse
Problem feels like DFS with overlapping subproblems

Example:
dp(index, remaining_sum)
But many sums are impossible


Step 3: When to use Iterative Top-Down
This is less commonly discussed. It means:

Iterative approach

But processing states in a dependency-driven order (like BFS / topo)
Use when:
State graph is not strictly small‚Üílarge
But recursion is risky
Example: DP on DAG, shortest path style DP

Examples
Longest path in DAG
DP with BFS layers
State transitions like graph traversal

Quick Decision Cheat Sheet
SituationApproachEasy natural order (index, length, grid)Bottom-UpHard to figure orderRecursive Top-DownSparse state spaceRecursive Top-DownLarge constraints / recursion riskBottom-UpTree DP / DFS structureRecursive Top-DownDAG / graph transitionsIterative Top-Down


Interview Strategy (Very Practical)

Write recursive solution first
Add memo ‚Üí Top-Down DP
If needed, convert to Bottom-Up
Interviewers like this flow.


Example Intuition
LCS
States depend on smaller prefixes ‚Üí Bottom-Up
Word Break
Branching choices, unknown valid states ‚Üí Top-Down
Tree diameter / subtree DP
Natural DFS ‚Üí Top-Down

Mental Rule (Fast)
Ask:
Can I sort states by size and fill? ‚Üí Bottom-Up
Does it feel like DFS with caching? ‚Üí Top-Down
Is recursion depth risky? ‚Üí Bottom-Up
